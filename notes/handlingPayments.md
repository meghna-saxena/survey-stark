##  Client side billing

- Work flow for the project =>
Server setup
Auth flow
Client setup
Auth on client
Billing on client
Add survey stuff on client
Add survey APIs on server
Setup billing on server


Billing refers to accepting credit cards or payments from the users and enabling some features inside the app based on whether the user has made payment.


## Billing consideration
- Add credits inside the app
- 1$ = 1 credit

- When user clicks `add credit`, show a form for entering credit card details
- Name, credit card number and submit button

### Rules of billing
- We(devs) are bad at security
- Maybe our deplyoment has some security issues and someone can access the db
    - Never accept raw credit card no.
    - Never store credit card no.
    - Always use an outside payment processor // some outside api or company who has setup building infrastructure in all the web security
        - Use `stripe`

- Billing is hard
    - Possible to avoid monthly payments/multiple plans
    - Frauds and chargebacks are a pain


## Stripe billing process
- Stripe as a payment processor
 How to collect credit card no from user without stroing them in the backend server

> Flow
 
 - User clicks 'Add credits'
 - Tell stripe to show credit card form (we install plugin authored by stripe into the application, so the form automatcially gets generated by stripe itself)
 - User enter CC details
 - Details sent directly from form to stripe API
 - Stripe sends back a token representing the charge (think it an autorization)
 - We send token to our API
 - Our API makes some followup req to stripe and confirms the charge was successful with stripe
 - Add credits to user's account



## Exploring the Stripe API
- Signup in stripe.com
- Get an api key to allow us to get payments
- When you first signup for stripe, your account works in test mode
- Test mode allows you to accept fake CC no for the purpose of testing applications, so we get some prest CC no that stipe accepts freely and assume as valid CC no.
- You can activate your account as well, then it will come out of test mode

- Inside Developers on left-side nav, you can see API keys
    - Here we have publishable key and secret key
    - Use publishable (public) key to identify our app to stripe, and use it in frontend of app
    - Secret key get stored in keys file in backend server, they cant be used in frontend and update env variable for heroku deployment

- Install stripe plugin on frontend side of application
    => Stripe checkout - generates a checkout form
    - uses checkout.js
    => However instead of using checkoutJS, we use react-stripe-checkout to enable stripe checkout work property with react app
    - So install `react-stripe-checkout` as npm module to frontend of app



## Stripe API keys

Setting keys config in server side -
- Use commonJS modules, so we can use some logic before using require statements
- Publishable key is a requirement for frontend of app, since react-stripe-checkout lib will need it.
- The backend wants both publishable and secret key


Setting keys config on frontend -
- ES15 modules is used characterized by import and export default statements so logic cant be written before listing import statements.
- How CRA helps in defining secret API keys



## Env variables with react
- Clinet side just cares about publishable key

Refer => https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables

- Define stripe key as env variable -> env variable extract out these keys to a separate file where we can list them as constants and freely chnage b/w sets of keys that we use for prod and development 

- Any custom env variable must begin with REACT_APP_ to avoid accidently exposing a private key on the machine.
- They will be accessed by process.env.___
- works exactly the same way as heroku env variables.


- Adding development env variable in `.env`

Inside client dir made 2 file 
    - .env.development
    - .env.production
and wrote publishable key, you can console log it in src/index.js by :

```
console.log('STRIPE KEY IS:', process.env.REACT_APP_STRIPE_KEY);
console.log('ENVIRONMENT IS:', process.env.NODE_ENV);
```



## The payments component
- Configure react-stripe-checkout component
- When we render it as react comp, it shows a btn that says buy now, when user click it, a form appears on screen.
- So after we configure this comp we will place it in header comp

- Make a comp that wrap stripe checkout thing and adds some config to it

```
import StripeCheckout from "react-stripe-checkout";

class Payments extends Component {
  render() {
    debugger;
    return (
      <StripeCheckout
        amount={500} //5$ = 500cents)
        token={token => console.log(token)} //callback func that gets called with a token received from stripe
        stripeKey={process.env.REACT_APP_STRIPE_KEY} //api key
      />
    );
  }
}

```



## Stripe tokens
- Inside header comp when we return the payment comp, we get the `pay with card` button by default. On clicking, it generates a form. We're working in `test mode` so CC no. to be used is `4242 4242 4242 4242`.
- Upon submission, we get back a token object which as an `id` used as auth token when express api interacts with stripe api



## Payment fixes
- Send the stripe token to express api, then our api will do followup req to stripe and then add some credits to the user a/c
- We dont actually have a user a/c, we actually have an obj or model inside db that represents a user
- So every user model will have a record of no. of current credits that they have.

- <StripeComp><button className="btn">Add Credits</button></StripeComp>
{/*child comp is displayed as btn rather than built-in btn by stripe checkout*/}



## Reusing action types
- Update the header with no. of credits
- User model will have a record of no. of credits
- When our app first boots up, we fetch the user model and save it inside authReducer


App boots up -> fetch current user -> Header updated
User pays money -> response sends back current user model with no. of credits -> Header updated

AuthReducer has user model. So we are not making another billing reducer. We're reusing our same reducer.

- Anytime you want to communicate with backend api, always make that req inside action creator.
- POST req to backend 

created action creator and reusing the same action type and payload so that authReducer can pick the same action, and update the usermodel in the header

```
export const handleToken = token => async dispatch => {
  const res = await axios.post("/api/stripe", token);

  dispatch({ type: FETCH_USER, payload: res.data });
};
```



## Posting the stripe token
The action creator gets called whenever we get a token from stripe checkout form, so that it post the token to backend api
- Inside payments.js -
` token={token => this.props.handleToken(token)} `


## POST request handlers
- Setup req handlers at express api to watch for post req to route `/api/stripe`

- In the req handler we have to put logic to reach stripe api and finalize the actual charge, and then update the user's no. of credits.


## Creating charges
- Install npm module specifically used for serverside of app to help with stripe api, so stripe checkout lib on frontend

npmjs.com -> `stripe` - a lib to work with node apps  
- We have to work with charges - to charge a credit/debit card, you create a charge object
- This charge obj is returned from stripe api



## Bodyparser middleware
- When you make req to express server, express doesnt by default parse the request payload
- So install `body-parser` another lib, which acts as express middleware to parse the req.
- Express middleware are wired up to express by app.use() call
- Parses the incoming req from stripe api to get the token, can see the value inside req.body   
`app.use(bodyParser.json());`



## Creating a charge object
- Inside route handler made the logic to create a charge by => `stripe.charges.create()`
- req.body.id is the token we got from stripe api, it is used as source property inside stripe charge


## Finalizing a charge
Pass callback async function as promises, so wrap the stripe.charge by async/await

```
module.exports = app => {
  app.post("/api/stripe", async (req, res) => {
    const charge = await stripe.charges.create({
      amount: 500,
      currency: "usd",
      description: "$5 for 5 credits",
      source: req.body.id
    });

    console.log(charge);
  });
};
``` 

On express server, you can see the charge by id: 'ch_.....'


__________________________________________________

> Note:

After the user submits the checkout form on the client side we get given a token from 'react-stripe-checkout' and then call the handleToken action creator with the token as an argument.

The handleToken() action creator then makes an asynchronous post request to our API at /api/stripe .

We then create a route handler on our API to receive this REQUEST coming in from the client side to then make another asynchronous post REQUEST to the stripe API?

We obtain the token in the route handler on the server then pass it along in a followup request from the server to stripe.  The thought process here is that we might want to do some secure processing on the token before passing it off to stripe - it wouldn't be appropriate for the client to reach directly out to stripe.



## Adding credits to a user
- We are building our users for some amt of money, we need to followup and give them no. of credits

User model 
    - googleId
    - credits <- default to 0

- req.user is current user, setup by passport
- respond to req with updates user model
- req.user.save() to save on db

```
const keys = require("../config/keys");
const stripe = require("stripe")(keys.stripeSecretKey);

module.exports = app => {
  app.post("/api/stripe", async (req, res) => {
    const charge = await stripe.charges.create({
      amount: 500,
      currency: "usd",
      description: "$5 for 5 credits",
      source: req.body.id
    });

    req.user.credits += 5;
    const user = await req.user.save(); //saves in db

    res.send(user);
  });
};
```